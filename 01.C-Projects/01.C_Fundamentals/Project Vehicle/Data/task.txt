17_0_1

● Дефинирайте нов тип VehicleShopInfo, който можем да ползваме за да държим
информация, свързана с отдаването на превозни средства под наем.
● Дефинирайте members за следната информация:
○ Година на производство
○ Име на марката
○ Име на модела
○ Уникален идентификатор на превозното средство (VIN)
○ Цена на ден
● Дефинирайте две променливи от тип VehicleShopInfo и ги инициализирайте.
● Принтирайте информацията за двете превозни средства.

17_8_1

Направете нова версия на програмата за отдаване на превозни средства под наем. В бъдеще ще разширим функционалността на
програмата да работи с файлове и дати, засега ще четем хард-коднати свободни превозни средства(ПС) и ще ги отдаваме едно по едно
докато не свършат или не излезем от програмата.
● Програмата трябва да има следните менюта:
○ Main Menu, със следните опции:
■ Press 1 to choose vehicle (води до Choose Vehicle Menu с всички свободни ПС)
■ Press 2 to choose vehicle by brand(води до Choose Brand Menu с всички марки от които има налични ПС, след което до
Choose Vehicle Menu с всички свободни ПС от избраната марка)
■ Press q to quit.
○ Choose Vehicle Menu - списък с множество свободни ПС(в зависимост от контекста, някой път всички, друг път - от дадена
марка), с опция за избор на ПС(водеща до Vehicle Details Menu) + опция за връщане в Main Menu (“Press b to go back to
Main Menu”)
○ Choose Brand Menu - списък с марки ПС, за които има налично свободно ПС. Дава възможност за избор на марка(при
което води до Choose Vehicle Menu със свободни ПС от избраната марка) или връщане в Main Menu
○ Vehicle Details Menu, със следното съдържание:
■ <Детайли за марката - име и кратка информация>
■ <Детайли за модела - име и кратка информация>
■ <Брой свободни ПС от тази марка и модел>
■ <Цена за наемане за едно денонощие>
■ Опции за наемане на ПС (за текущото изпълнение на програмата) и за връщане в предходното меню - Choose Vehicle
Menu (с последните филтри за менюто)

17_8_2

● Направете отделен модул (в отделни .h и .c файлове) за съхранение на информацията, свързана с различните марки
и модели на превозни средства. За всяка марка, както и за всеки модел от дадена марка трябва да пазим име и
кратко описание на марката/модела. В бъдеще модулът ще има функции за четене на информацията от файл(ове)
или от мрежата, засега можем да хард-коднем примерни данни.
● Направете отделен модул за съхранение и достъп до информацията за всичките ПС на компанията, с цена за
денонощие и наличност (дали е наличен за текущото изпълнение на програмата засега)
● Напревете трети, основен модул на програмата, който да чете избора на потребителя и да контролира потока на
изпълнение на програмата, на базата на направения от потребителя избор.
● Дефинирайте и използвайте отделни типове за различните видове данни:
○ Информация за марка(име и кратко описание засега)
○ Информация за модел от марка(име и кратко описание засега)
○ Информация за превозните средства с които разполага компанията(марка, модел, наличност, цена за всяко ПС)


18_4

Дефинирайте структура, която репрезентира календарна дата (например: struct datetime)
и има членове за:
● Година
● Месец
● Ден от месеца
Нека направим модул за дни и дати за програмата за отдаване на ПС под наем (пример: datetime.h, datetime.c).
За целта, може да ползвате типовете (tm, например) и функциите от <time.h>

20_1

Дефинирайте структура UserInfo със следните данни за всеки потребител:
● Категория на шофьорска книжка ( ползвайте enum за различните категории )
● Три имена
● ЕГН ( PIN )
Дефинирайте функции за сериализация(писане) и десериализация(четене) на обект от тип UserInfo.
Тествайте с текстов файл с данни за потребител и програма, която прочита файла, променя нещо и
го записва във същия файл.

20_2

Дефинирайте функция за сериализация на масив от обекти от тип UserInfo.
Тествайте с прочитане на файл с множество данни за потребители, променяне на данните и
записване на новата информация в същия файл.

20_4

За програмата с отдаване на МПС под наем, направете следната функционалност:
Дефинирайте функции за сериализация и десериализация на типовете, които ползвате за съхранение
на информация за марка и за информация за модел (Meeting17_structures - Задача 8 (2/2))
Дефинирайте функции за сериализиране и десериализиране на обектите от тези типове, които се
съхраняват в модула, който е предназначен за съхранението на общата информация за марки и
модели на МПС.
Извикайте функцията за прочитане на данните от файл при стартиране на приложението.

20_5

Добавете подменю в MainMenu, в което да позволява въвеждане на информация за нова марка и
модел, след което записва нововъведената информация във файла, който съдържа всички данни за
марки и модели МПС.

20_7

Рефакторирайте структурата, която съдържа информация за превозно средство, с което компанията
разполага да съдържа следната информация:
● Марка
● Модел
● Необходима категория за шофьорска книжка (използвайте enum-а от Задача 1)
● VIM (Уникален идентификационен номер)
● Година на производство
Дефинирайте функции за сериализиране и десериализиране на обектите от тези типове, които се
съхраняват в модула, който е предназначен за съхранението и обработката на общата информация за
превозните средства, с които разполага компанията.
Извикайте функцията за прочитане на данните от файл(файл с фирмени ПС) при стартиране на
приложението

20_8

Направете меню за добавяне на новозакупен автомобил, който може да бъде даван под наем, както и за
премахване от автомобил от списъка с автомобили, с които разполага компанията.
Запазвайте промените във файл(файл с фирмени ПС)

21_12

Да променим програмата така че да поддържа различни менюта и опции за различните видове потребители:
● Потребител от тип Owner ще може всичко
● Потребител от тип Admin ще може всичко като Owner, без да може да добавя/премахва фирмени ПС, 
както и да редактира информация замарка/модел
● Потребител от тип User ще може само да резервира и да отлага резервация.
Дефинирайте enum константи за различните възможности, които ще предлага приложението, в зависимост 
от типа на потредбителя
enum E_APP_PERMISSION_FLAGS
{
 E_BOOK_VEHICLE = //..
 E_UNBOOK_VEHICLE = //..,
 E_EDIT_VEHICLE_INFO = //..,
 E_ADD_REMOVE_VEHICLE = //..,
 E_EDIT_BRAND_INFO = //..
};
Използвайте такива стойности за константите, че да можем да ги ползваме като маски/флагове - всяка константа 
трябва да има 0 на всяка позиция,освен на позиция, която е уникална за константата ( пример побитов запис 
на четири различни константи: 0001, 0010, 0100, 1000 )
За да напишете стойностите на константите използвайте или оператор <<, или целочислени бинарни литерали

21_13

Дефинирайте enum константи за различните видове потребители на приложението - Owner, Admin, User
enum Е_APP_USER {
 Е_OWNER = //...
 Е_ADMIN = //...
 Е_USER = //...
};
Използвайте стойностите от E_APP_PERMISSION_FLAGS и други стойности от Е_APP_USER (по-горни) за да дефинирате 
комбинации от различни опции за всеки потребител.
Използвайте оператор | за комбиниране на опции и оператори & и ~ за изключване на опция. Примери:
E_EDIT_BRAND_INFO | E_EDIT_VEHICLE_INFO // E_EDIT_BRAND_INFO И E_EDIT_VEHICLE_INFO
Е_ADMIN &~EDIT_BRAND_INFO // каквото имаме за Е_ADMIN без EDIT_BRAND_INFO
0xff &~EDIT_BRAND_INFO // всичко без EDIT_BRAND_INFO
Стартирайте приложението/main menu по подобен начин:
start_app(Е_APP_USER_PERMISSION_LEVEL_USER );
(На по-късен етап ще направим login меню, от което ще идва информацията за типа на потребителя)
